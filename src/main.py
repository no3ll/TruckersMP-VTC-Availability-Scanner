# src/main.py

"""
main.py

CLI helper that:
- Asks for TruckersMP event URLs (your event + other events at same time).
- Scrapes those event pages to find "busy" VTC IDs.
- Loads candidate VTCs from vtcs_source.json (generated by augment_vtcs_from_events.py).
- Filters out busy VTCs and applies:
    - status filter (verified / validated / normal)
    - game filter (ETS2 / ATS / both / any)
    - recruitment filter (open only vs any)
- Prints suggested VTCs grouped by status:
    - VERIFIED
    - VALIDATED
    - NORMAL
"""

from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Any, Dict, List, Optional, Set

import requests
from bs4 import BeautifulSoup

BASE_SITE_URL = "https://truckersmp.com"

HEADERS = {
    "User-Agent": (
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
        "AppleWebKit/537.36 (KHTML, like Gecko) "
        "Chrome/120.0.0.0 Safari/537.36 "
        "EventVTCFinder/0.1"
    )
}


def get_project_root() -> Path:
    """Return the project root (one level above src/)."""
    return Path(__file__).resolve().parents[1]


def get_vtc_source_file() -> Path:
    """Path to vtcs_source.json in the project root."""
    return get_project_root() / "vtcs_source.json"


def extract_event_id(event_url: str) -> Optional[int]:
    """
    Extract the numeric event ID from a TruckersMP event URL.
    Example: https://truckersmp.com/events/30724-tccr-monthly-convoy -> 30724
    """
    m = re.search(r"/events/(\d+)", event_url)
    if not m:
        return None
    try:
        return int(m.group(1))
    except ValueError:
        return None


def get_attending_vtcs_html(event_id: int) -> Set[int]:
    """
    Scrape the TruckersMP event page and extract all VTC IDs
    that appear as /vtc/<id> links anywhere on the page.
    """
    url = f"{BASE_SITE_URL}/events/{event_id}"
    print(f"\nFetching attending VTCs for event {event_id}...")
    print(f"[DEBUG] Fetching real attending VTCs for event {event_id}...")
    print(f"[DEBUG] Requesting event page: {url}")

    try:
        resp = requests.get(url, headers=HEADERS, timeout=15)
    except requests.RequestException as e:
        print(f"[WARN] Failed to fetch event page {url}: {e}")
        return set()

    if resp.status_code != 200:
        print(f"[WARN] HTTP {resp.status_code} when fetching {url}")
        return set()

    soup = BeautifulSoup(resp.text, "html.parser")
    vtc_ids: Set[int] = set()

    for a in soup.find_all("a", href=True):
        href = a.get("href")
        if not isinstance(href, str):
            continue
        m = re.search(r"/vtc/(\d+)", href)
        if m:
            try:
                vtc_ids.add(int(m.group(1)))
            except ValueError:
                continue

    print(f"[DEBUG] Found {len(vtc_ids)} VTC(s) linked on the event page.")
    print(f"  Found {len(vtc_ids)} attending VTC(s).")
    return vtc_ids


def load_vtcs(path: Path) -> List[Dict[str, Any]]:
    """Load candidate VTCs from vtcs_source.json."""
    if not path.exists():
        print(f"[ERROR] {path} does not exist. Run augment_vtcs_from_events.py first.")
        return []

    try:
        with path.open("r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception as e:
        print(f"[ERROR] Failed to load {path}: {e}")
        return []

    if not isinstance(data, list):
        print(f"[ERROR] {path} does not contain a JSON list.")
        return []

    print(f"[DEBUG] Loaded {len(data)} candidate VTC(s) from vtcs_source.json.")
    return data


def ask_status_filter() -> str:
    """
    Return one of:
      'verified_only'
      'verified_validated'
      'all'
      'normal_only'
    """
    print("\nChoose status filter:")
    print("  1) Verified only")
    print("  2) Verified + validated (recommended)")
    print("  3) All (verified, validated, normal)")
    print("  4) Normal only")
    choice = input("Selection (1/2/3/4, default 2): ").strip()

    if choice == "1":
        return "verified_only"
    if choice == "3":
        return "all"
    if choice == "4":
        return "normal_only"
    # default
    return "verified_validated"


def ask_game_filter() -> str:
    """
    Return one of:
      'ets2'
      'ats'
      'both'
      'any'
    """
    print("\nGame filter:")
    print("  1) ETS2 only")
    print("  2) ATS only")
    print("  3) Both ETS2 & ATS")
    print("  4) Any (default)")
    choice = input("Selection (1/2/3/4, default 4): ").strip()

    if choice == "1":
        return "ets2"
    if choice == "2":
        return "ats"
    if choice == "3":
        return "both"
    # default
    return "any"


def ask_recruitment_filter() -> str:
    """
    Return one of:
      'open_only'
      'any'
    """
    print("\nRecruitment filter:")
    print("  1) Only VTCs with recruitment OPEN (recommended)")
    print("  2) Any recruitment status")
    choice = input("Selection (1/2, default 1): ").strip()

    if choice == "2":
        return "any"
    # default
    return "open_only"


def passes_status_filter(vtc: Dict[str, Any], status_filter: str) -> bool:
    status_raw = vtc.get("status", "normal")
    if not isinstance(status_raw, str):
        status_raw = str(status_raw)
    status = status_raw.lower()

    if status_filter == "verified_only":
        return status == "verified"
    if status_filter == "verified_validated":
        return status in ("verified", "validated")
    if status_filter == "normal_only":
        return status == "normal"
    # "all"
    return True


def passes_game_filter(vtc: Dict[str, Any], game_filter: str) -> bool:
    games = vtc.get("games", [])
    if not isinstance(games, list):
        games = []

    games_upper = {str(g).upper() for g in games}

    if game_filter == "ets2":
        return "ETS2" in games_upper
    if game_filter == "ats":
        return "ATS" in games_upper
    if game_filter == "both":
        return "ETS2" in games_upper and "ATS" in games_upper
    # "any"
    return True


def passes_recruitment_filter(vtc: Dict[str, Any], recruitment_filter: str) -> bool:
    recruitment_raw = vtc.get("recruitment", "unknown")
    if not isinstance(recruitment_raw, str):
        recruitment_raw = str(recruitment_raw)
    recruitment = recruitment_raw.lower()

    if recruitment_filter == "open_only":
        return recruitment == "open"
    # "any"
    return True


def print_grouped_vtcs(free_vtcs: List[Dict[str, Any]]) -> None:
    """Print free VTCs grouped by status (verified / validated / normal)."""
    verified: List[Dict[str, Any]] = []
    validated: List[Dict[str, Any]] = []
    normal: List[Dict[str, Any]] = []

    for vtc in free_vtcs:
        status_raw = vtc.get("status", "normal")
        if not isinstance(status_raw, str):
            status_raw = str(status_raw)
        status = status_raw.lower()

        if status == "verified":
            verified.append(vtc)
        elif status == "validated":
            validated.append(vtc)
        else:
            normal.append(vtc)

    # Sort each group alphabetically by name
    def safe_name(v: Dict[str, Any]) -> str:
        n = v.get("name", "")
        return str(n)

    verified.sort(key=safe_name)
    validated.sort(key=safe_name)
    normal.sort(key=safe_name)

    def print_vtc_line(v: Dict[str, Any]) -> None:
        vid = v.get("id", "?")
        name = v.get("name", f"VTC {vid}")
        recruitment = str(v.get("recruitment", "unknown")).lower()
        tmp_url = v.get("tmp_url", f"https://truckersmp.com/vtc/{vid}")
        discord_invites = v.get("discord_invites", [])
        if not isinstance(discord_invites, list):
            discord_invites = []

        # Main line
        print(f" - {name} (ID {vid})")
        # TMP link
        print(f"    TMP: {tmp_url}")
        # Recruitment if known
        if recruitment in ("open", "closed"):
            print(f"    Recruitment: {recruitment.upper()}")
        # Discord (first invite, if any)
        if discord_invites:
            print(f"    Discord: {discord_invites[0]}")

    print("\n=== Suggested VTCs to Invite ===\n")

    if verified:
        print("────────── VERIFIED VTCs ──────────")
        for v in verified:
            print_vtc_line(v)
        print()

    if validated:
        print("────────── VALIDATED VTCs ──────────")
        for v in validated:
            print_vtc_line(v)
        print()

    if normal:
        print("────────── NORMAL VTCs ──────────")
        for v in normal:
            print_vtc_line(v)
        print()


def main() -> None:
    print(f"DEBUG: main.py is running from {Path(__file__).resolve()}")
    print("=== TruckersMP VTC Availability Helper ===\n")

    # --- Ask for event URLs ---
    print("Enter TruckersMP event URLs (comma separated).")
    print("Include YOUR event and other events at that time.")
    event_urls_str = input("> ").strip()
    if not event_urls_str:
        print("No event URLs provided. Exiting.")
        return

    event_urls = [u.strip() for u in event_urls_str.split(",") if u.strip()]
    event_ids: List[int] = []

    for url in event_urls:
        eid = extract_event_id(url)
        if eid is None:
            print(f"[WARN] Could not extract event ID from URL: {url}")
        else:
            event_ids.append(eid)

    if not event_ids:
        print("No valid event IDs extracted. Exiting.")
        return

    # --- Collect busy VTC IDs from those events ---
    busy_vtc_ids: Set[int] = set()
    for eid in event_ids:
        ids_for_event = get_attending_vtcs_html(eid)
        busy_vtc_ids.update(ids_for_event)

    print(f"\nTotal unique busy VTCs across these events: {len(busy_vtc_ids)}\n")

    # --- Load candidates from vtcs_source.json ---
    vtc_file = get_vtc_source_file()
    candidates = load_vtcs(vtc_file)
    if not candidates:
        print("No candidate VTCs loaded. Exiting.")
        return

    print(f"Total candidate VTCs: {len(candidates)}\n")

    # --- Ask filters ---
    status_filter = ask_status_filter()
    game_filter = ask_game_filter()
    recruitment_filter = ask_recruitment_filter()

    # --- Filter VTCs ---
    free_vtcs: List[Dict[str, Any]] = []
    for vtc in candidates:
        vid_raw = vtc.get("id")

        # Safe conversion to int to satisfy Pylance:
        if isinstance(vid_raw, int):
            vid = vid_raw
        elif isinstance(vid_raw, str):
            try:
                vid = int(vid_raw)
            except ValueError:
                continue
        else:
            # If it's None or some other type, skip this VTC
            continue

        if vid in busy_vtc_ids:
            continue

        if not passes_status_filter(vtc, status_filter):
            continue
        if not passes_game_filter(vtc, game_filter):
            continue
        if not passes_recruitment_filter(vtc, recruitment_filter):
            continue

        free_vtcs.append(vtc)

    print_grouped_vtcs(free_vtcs)

    print(
        f"Summary: {len(free_vtcs)} free VTC(s) matched your filters out of "
        f"{len(candidates)} tracked candidates."
    )
    print("Done.")


if __name__ == "__main__":
    main()
